# -*- coding: utf-8 -*-

"""
/***************************************************************************
 ProgramacaoAplicadaGrupo2
                                 A QGIS plugin
 Solução do Grupo 2
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-04-28
        copyright            : (C) 2024 by Grupo 2
        email                : analivia.200012@ime.eb.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Grupo 2'
__date__ = '2024-04-28'
__copyright__ = '(C) 2024 by Grupo 2'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (
    QgsProcessing,
    QgsProcessingAlgorithm,
    QgsProcessingParameterVectorLayer,
    QgsProcessingParameterEnum,
    QgsProcessingParameterRasterLayer,
    QgsProcessingParameterFeatureSink,
    QgsProcessingException,
    QgsFeatureRequest,
    QgsProject,
    QgsFeature,
    QgsProcessingMultiStepFeedback,
    QgsProcessingParameterVectorDestination,
    QgsProcessingContext,
    QgsFeedback,
    QgsFields,
    QgsField,
    QgsFeature,
    QgsGeometry,
    QgsWkbTypes,
    QgsPointXY,
    QgsFeatureSink
)
from qgis import processing
from qgis.PyQt.QtCore import QVariant

class DadosMDTComplementarAlgorithm(QgsProcessingAlgorithm):
    # Definindo constantes para os parâmetros
    MDT = "MDT"
    INPUT_CURVAS = "INPUT_CURVAS"
    INPUT_MOLDURA = "INPUT_MOLDURA"
    OUTPUT = "OUTPUT"

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.INPUT_CURVAS,
                self.tr("Curvas de Nível"),
                [QgsProcessing.TypeVectorLine]
            )
        )
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.MDT,
                self.tr("Modelo Digital de Terreno (MDT)")
            )
        )
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.INPUT_MOLDURA,
                self.tr("Moldura para Análise"),
                [QgsProcessing.TypeVectorPolygon]
            )
        )
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr("Pontos de Elevação Máxima")
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        curvas_nivel = self.parameterAsSource(parameters, self.INPUT_CURVAS, context)
        mdt_layer = self.parameterAsRasterLayer(parameters, self.MDT, context)
        moldura = self.parameterAsVectorLayer(parameters, self.INPUT_MOLDURA, context)

        fields = QgsFields()
        fields.append(QgsField("cota", QVariant.Double))

        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUTPUT,
            context,
            fields,
            QgsWkbTypes.Point,
            curvas_nivel.sourceCrs()
        )

        moldura_geom = [f.geometry() for f in moldura.getFeatures()][0] if moldura else None
        total = 100.0 / curvas_nivel.featureCount() if curvas_nivel.featureCount() else 0

        for current, curva in enumerate(curvas_nivel.getFeatures()):
            if feedback.isCanceled():
                break

            if moldura_geom and not moldura_geom.intersects(curva.geometry()):
                continue  # Skip curves outside the frame

            if self.is_curva_isolada(curva, curvas_nivel):
                highest_point, highest_value = self.find_highest_point(curva.geometry(), mdt_layer)
                if highest_point:
                    feat = QgsFeature(fields)
                    feat.setGeometry(QgsGeometry.fromPointXY(highest_point))
                    feat.setAttributes([round(highest_value, 1)])  # Round elevation to one decimal place
                    sink.addFeature(feat, QgsFeatureSink.FastInsert)

            feedback.setProgress(int(current * total))

        return {self.OUTPUT: dest_id}

    def is_curva_isolada(self, curva, curvas_nivel):
        geom_curva = curva.geometry().buffer(0.001, 10)  # Small buffer to ensure no touching lines are considered inside
        for other_curva in curvas_nivel.getFeatures():
            if other_curva.id() != curva.id() and geom_curva.contains(other_curva.geometry()):
                return False
        return True

    def find_highest_point(self, geometry, mdt_layer):
        highest_point = None
        highest_value = float('-inf')
        bbox = geometry.boundingBox()
        step = max(bbox.width(), bbox.height()) / 50  # Dynamic step size based on the size of the bounding box

        x = bbox.xMinimum()
        while x <= bbox.xMaximum():
            y = bbox.yMinimum()
            while y <= bbox.yMaximum():
                point = QgsPointXY(x, y)
                if geometry.contains(point):
                    value = mdt_layer.dataProvider().sample(point, 1)
                    if value[0] > highest_value:
                        highest_point, highest_value = point, value[0]
                y += step
            x += step
        return highest_point, highest_value

    def name(self):
        return 'Solução complementar do projeto 2'

    def displayName(self):
        return self.tr(self.name())

    def group(self):
        return self.tr(self.groupId())

    def groupId(self):
        return 'Projeto 2'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return DadosMDTComplementarAlgorithm()
